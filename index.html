<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shades: Color Theory Puzzle Game</title>
    <style>
        /* Modern, clean design with professional color palette */
        :root {
            --primary: #3a506b;
            --secondary: #5bc0be;
            --light: #f0f5f9;
            --dark: #1c2541;
            --accent: #6fffe9;
            --success: #4caf50;
            --error: #f44336;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--light);
            color: var(--dark);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--secondary);
            margin-bottom: 20px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 95%;
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (min-width: 900px) {
            .game-container {
                flex-direction: row;
                align-items: flex-start;
            }
        }

        .matrix-container {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
        }

        .matrix-title {
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary);
            font-size: 1.5rem;
        }

        .matrix {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 12px;
            aspect-ratio: 1/1;
            width: 100%;
            min-height: 400px;
            position: relative;
        }
        
        .row-labels {
            position: absolute;
            left: -100px; /* Increased space for row labels */
            top: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            padding: 25px 0;
            width: 95px; /* Fixed width for labels */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.3s ease;
            pointer-events: none; /* So it doesn't interfere with gameplay */
        }
        
        .row-labels.visible {
            opacity: 1;
        }
        
        .row-label {
            display: flex;
            align-items: center;
            margin: 0;
            font-weight: bold;
            color: var(--primary);
            height: calc(20% - 9.6px); /* Adjusts for the gaps in the grid */
        }
        
        .row-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--primary);
            color: white;
            margin-right: 8px;
            font-size: 0.9rem;
        }
        
        .row-type {
            font-size: 0.8rem;
        }

        .tile {
            position: relative;
            border-radius: 8px;
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            aspect-ratio: 1/1;
        }
        
        .solution-tile {
            box-shadow: 0 0 10px rgba(106, 255, 170, 0.7);
            border: 2px solid rgba(106, 255, 170, 0.9);
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .tile.locked {
            cursor: not-allowed;
            overflow: hidden;
        }

        .tile.locked::after {
            content: "ðŸ”’";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #2a3f56;
        }

        button:active {
            transform: scale(0.98);
        }

        #hint-button {
            background-color: var(--secondary);
        }

        #hint-button:hover {
            background-color: #4ca8a6;
        }

        #check-button {
            background-color: var(--accent);
            color: var(--dark);
        }

        #check-button:hover {
            background-color: #63e5d1;
        }
        
        #palette-button {
            background-color: #9e6bb5;
            color: white;
        }
        
        #palette-button:hover {
            background-color: #7d5491;
        }

        #reset-button {
            background-color: var(--dark);
        }

        #reset-button:hover {
            background-color: #141e32;
        }

        .message-area {
            min-height: 60px;
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .success {
            background-color: rgba(76, 175, 80, 0.2);
            color: var(--success);
        }

        .error {
            background-color: rgba(244, 67, 54, 0.2);
            color: var(--error);
        }

        .hint {
            background-color: rgba(91, 192, 190, 0.2);
            color: var(--secondary);
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 800px;
        }
        
        .stat {
            text-align: center;
            font-weight: bold;
        }
        
        .stat-value {
            font-size: 1.5rem;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: var(--secondary);
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-10px); }
            80% { transform: translateX(10px); }
        }
        
        .shake {
            animation: shake 0.5s;
            border: 2px solid var(--error);
        }
        
        .game-info {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 800px;
        }

        .game-info h2 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .game-info p {
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .palette-info {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .palette-type {
            flex: 1 1 200px;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
        }

        .palette-type h3 {
            font-size: 1rem;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .color-sample {
            display: flex;
            height: 20px;
            margin-top: 5px;
        }
        
        .color-sample div {
            flex: 1;
            height: 100%;
        }

        @media (max-width: 1024px) {
            .row-labels {
                left: -85px;
                width: 80px;
            }
        }
        
        @media (max-width: 768px) {
            .matrix {
                gap: 8px;
                min-height: 300px;
            }
            
            .controls {
                flex-direction: column;
                width: 100%;
            }
            
            button {
                width: 100%;
            }
            
            .row-labels {
                left: -70px;
                width: 65px;
            }
            
            .row-number {
                width: 20px;
                height: 20px;
                font-size: 0.8rem;
            }
            
            .row-type {
                font-size: 0.7rem;
            }
        }
        
        @media (max-width: 600px) {
            .row-labels {
                left: -55px;
                width: 50px;
            }
        }
        
        @media (max-width: 500px) {
            .row-labels {
                left: -40px;
                width: 35px;
            }
            
            .row-type {
                display: none; /* Hide palette type labels on very small screens */
            }
        }

        /* Animation for when tiles are placed correctly */
        @keyframes correctPlacement {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .correct {
            animation: correctPlacement 0.5s;
            border: 2px solid var(--success);
        }
    </style>
</head>
<body>
    <header>
        <h1>Shades</h1>
        <div class="subtitle">Color Theory Puzzle Game</div>
    </header>

    <div class="game-container">
        <div class="matrix-container">
            <h2 class="matrix-title">Scrambled Matrix</h2>
            <div id="scrambled-matrix" class="matrix">
                <!-- Tiles will be generated by JavaScript -->
            </div>
        </div>
        
        <div class="matrix-container">
            <h2 class="matrix-title">Solution Matrix</h2>
            <!-- Row labels will appear on the left side of the solution matrix -->
            <div class="row-labels">
                <div class="row-label">
                    <div class="row-number">1</div>
                    <div class="row-type">Monochromatic</div>
                </div>
                <div class="row-label">
                    <div class="row-number">2</div>
                    <div class="row-type">Analogous</div>
                </div>
                <div class="row-label">
                    <div class="row-number">3</div>
                    <div class="row-type">Complementary</div>
                </div>
                <div class="row-label">
                    <div class="row-number">4</div>
                    <div class="row-type">Split-Compl.</div>
                </div>
                <div class="row-label">
                    <div class="row-number">5</div>
                    <div class="row-type">Triadic</div>
                </div>
            </div>
            <div id="solution-matrix" class="matrix">
                <!-- Tiles will be generated by JavaScript -->
            </div>
        </div>
    </div>
    
    <div id="message" class="message-area"></div>
    
    <div class="game-stats">
        <div class="stat">
            <div id="timer-value" class="stat-value">00:00</div>
            <div class="stat-label">Time</div>
        </div>
        <div class="stat">
            <div id="blunder-value" class="stat-value">0</div>
            <div class="stat-label">Blunders</div>
        </div>
    </div>
    
    <div class="controls">
        <button id="check-button">Show Solution</button>
        <button id="hint-button">Show Hint</button>
        <button id="palette-button">Show Palette Types</button>
        <button id="reset-button">Reset Game</button>
    </div>

    <div class="game-info">
        <h2>How to Play:</h2>
        <p>Drag tiles from the Scrambled Matrix on the left and drop them into the Solution Matrix on the right. The center column shows key colors for each palette type. Arrange tiles to match the correct color relationships. Click "Show Solution" to reveal the correct arrangement or check your work.</p>
        
        <div class="palette-info">
            <div class="palette-type">
                <h3>Row 1: Monochromatic</h3>
                <p>Variations in lightness of a single hue</p>
                <div class="color-sample">
                    <div style="background-color: #bde0fe;"></div>
                    <div style="background-color: #a2d2ff;"></div>
                    <div style="background-color: #8ac8ff;"></div>
                    <div style="background-color: #72beff;"></div>
                    <div style="background-color: #5ab4ff;"></div>
                </div>
            </div>
            <div class="palette-type">
                <h3>Row 2: Analogous</h3>
                <p>Adjacent colors on the color wheel</p>
                <div class="color-sample">
                    <div style="background-color: #ffadad;"></div>
                    <div style="background-color: #ffd6a5;"></div>
                    <div style="background-color: #fdffb6;"></div>
                    <div style="background-color: #caffbf;"></div>
                    <div style="background-color: #9bf6ff;"></div>
                </div>
            </div>
            <div class="palette-type">
                <h3>Row 3: Complementary</h3>
                <p>Opposite colors on the color wheel</p>
                <div class="color-sample">
                    <div style="background-color: #ff5c8a;"></div>
                    <div style="background-color: #ff8fab;"></div>
                    <div style="background-color: #ffffff;"></div>
                    <div style="background-color: #a0c4ff;"></div>
                    <div style="background-color: #4361ee;"></div>
                </div>
            </div>
            <div class="palette-type">
                <h3>Row 4: Split Complementary</h3>
                <p>Base + two flanking colors</p>
                <div class="color-sample">
                    <div style="background-color: #ff7b00;"></div>
                    <div style="background-color: #ff9e00;"></div>
                    <div style="background-color: #40916c;"></div>
                    <div style="background-color: #52b788;"></div>
                    <div style="background-color: #b5179e;"></div>
                </div>
            </div>
            <div class="palette-type">
                <h3>Row 5: Triadic</h3>
                <p>Three equidistant colors</p>
                <div class="color-sample">
                    <div style="background-color: #f15bb5;"></div>
                    <div style="background-color: #f8c537;"></div>
                    <div style="background-color: #00bbf9;"></div>
                    <div style="background-color: #f15bb5;"></div>
                    <div style="background-color: #00bbf9;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Color palettes definition (these could be generated programmatically in a more advanced version)
            const palettes = {
                monochromatic: ['#e6f2ff', '#bfd9ff', '#99c2ff', '#6699ff', '#3366ff'],
                analogous: ['#ff9999', '#ffcc99', '#ffff99', '#ccff99', '#99ffcc'],
                complementary: ['#ff5555', '#ff9999', '#ffffff', '#9999ff', '#5555ff'],
                splitComplementary: ['#ff6600', '#ff9933', '#33cc99', '#66cc99', '#cc33cc'],
                triadic: ['#ff5555', '#55ff55', '#5555ff', '#ff5555', '#5555ff']
            };
            
            // Game elements
            const scrambledMatrix = document.getElementById('scrambled-matrix');
            const solutionMatrix = document.getElementById('solution-matrix');
            const messageArea = document.getElementById('message');
            const checkButton = document.getElementById('check-button');
            const hintButton = document.getElementById('hint-button');
            const resetButton = document.getElementById('reset-button');
            
            // Game state
            let draggedTile = null;
            let activeTiles = [];
            let blunders = 0;
            let startTime = null;
            let timerInterval = null;
            let solutionVisible = false; // Track if solution is currently shown
            let paletteTypesVisible = false; // Track if palette types are visible
            
            // Initialize game
            function initGame() {
                // Clear matrices
                scrambledMatrix.innerHTML = '';
                solutionMatrix.innerHTML = '';
                messageArea.textContent = '';
                messageArea.className = 'message-area';
                
                // Reset game stats
                blunders = 0;
                updateBlunderDisplay();
                
                // Reset and start timer
                startTime = new Date();
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(updateTimer, 1000);
                updateTimer();
                
                // Reset visibility states
                solutionVisible = false;
                paletteTypesVisible = false;
                
                // Hide palette types UI
                const rowLabels = document.querySelector('.row-labels');
                rowLabels.classList.remove('visible');
                
                // Reset palette button text
                const paletteButton = document.getElementById('palette-button');
                if (paletteButton) {
                    paletteButton.textContent = "Show Palette Types";
                }
                
                // Create all color tiles
                const allColors = [];
                Object.values(palettes).forEach(palette => {
                    allColors.push(...palette);
                });
                
                // Create scrambled tiles
                const scrambledColors = [...allColors].sort(() => Math.random() - 0.5);
                scrambledColors.forEach((color, index) => {
                    const tile = createTile(color, index, 'scrambled');
                    tile.dataset.originalIndex = index; // Store original position
                    scrambledMatrix.appendChild(tile);
                });
                
                // Create solution matrix with locked center column
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        // Calculate the index in a 5x5 grid
                        const index = row * 5 + col;
                        
                        // For center column (col = 2), place locked tiles with the correct colors
                        if (col === 2) {
                            const paletteType = Object.keys(palettes)[row];
                            const palette = palettes[paletteType];
                            const centerTile = createTile(palette[2], index, 'locked');
                            centerTile.classList.add('locked');
                            solutionMatrix.appendChild(centerTile);
                        } else {
                            // Create empty slots for other positions
                            const emptySlot = document.createElement('div');
                            emptySlot.className = 'tile empty-slot';
                            emptySlot.dataset.index = index;
                            emptySlot.addEventListener('dragover', handleDragOver);
                            emptySlot.addEventListener('drop', handleDrop);
                            solutionMatrix.appendChild(emptySlot);
                        }
                    }
                }
                
                // Update active tiles
                updateActiveTiles();
            }
            
            // Create a color tile
            function createTile(color, index, type) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                
                // Create subtle gradient effect with the base color
                const lighterColor = lightenColor(color, 15);
                const darkerColor = darkenColor(color, 15);
                tile.style.background = `linear-gradient(135deg, ${lighterColor}, ${color} 50%, ${darkerColor})`;
                
                tile.dataset.color = color;
                tile.dataset.index = index;
                
                // Check if this is a center column tile (always locked)
                const col = index % 5;
                const isLockedPosition = col === 2;
                
                if (isLockedPosition && type === 'solution') {
                    tile.classList.add('locked');
                } else if (type === 'scrambled' || type === 'solution') {
                    // Make tiles draggable except for locked ones
                    tile.draggable = true;
                    tile.addEventListener('dragstart', handleDragStart);
                    tile.addEventListener('dragend', handleDragEnd);
                }
                
                return tile;
            }
            
            // Helper function to lighten a color
            function lightenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, (num >> 16) + amt);
                const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
                const B = Math.min(255, (num & 0x0000FF) + amt);
                return '#' + (0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1);
            }
            
            // Helper function to darken a color
            function darkenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max(0, (num >> 16) - amt);
                const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
                const B = Math.max(0, (num & 0x0000FF) - amt);
                return '#' + (0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1);
            }
            
            // Drag and Drop Handlers
            function handleDragStart(e) {
                draggedTile = this;
                this.style.opacity = '0.4';
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.color);
                // Store information about the source of the drag operation
                draggedTile.dataset.sourceMatrix = this.closest('#scrambled-matrix') ? 'scrambled' : 'solution';
            }
            
            function handleDragEnd(e) {
                this.style.opacity = '1';
                draggedTile = null;
            }
            
            function handleDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary to allow drop
                }
                e.dataTransfer.dropEffect = 'move';
                return false;
            }
            
            function handleDrop(e) {
                e.preventDefault();
                
                if (!draggedTile) return;
                
                // Get the row of the drop target and color info
                const targetIndex = parseInt(this.dataset.index);
                const targetRow = Math.floor(targetIndex / 5);
                const targetCol = targetIndex % 5;
                const paletteType = Object.keys(palettes)[targetRow];
                const correctPalette = palettes[paletteType];
                const tileColor = draggedTile.dataset.color;
                
                // Check if the color belongs to the correct palette (correct row)
                const colorInPalette = correctPalette.includes(tileColor);
                const colorPositionInPalette = correctPalette.indexOf(tileColor);
                
                // Check if we're moving from the solution matrix or the scrambled matrix
                const isMovingWithinSolution = draggedTile.dataset.sourceMatrix === 'solution';
                
                // Get all existing tiles in this row to check for duplicates
                const rowTiles = [];
                for (let col = 0; col < 5; col++) {
                    const index = targetRow * 5 + col;
                    const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]:not(.empty-slot)`);
                    if (tile && !tile.classList.contains('empty-slot')) {
                        rowTiles.push({
                            color: tile.dataset.color,
                            index: index
                        });
                    }
                }
                
                // Check for duplicate color in the row (except for the one we're moving)
                const hasDuplicate = rowTiles.some(tile => 
                    tile.color === tileColor && 
                    (!isMovingWithinSolution || (isMovingWithinSolution && parseInt(draggedTile.dataset.index) !== tile.index))
                );
                
                // If there's a duplicate and this isn't the tile we're moving within the row, show error
                if (hasDuplicate) {
                    // Duplicate color - count as blunder
                    blunders++;
                    updateBlunderDisplay();
                    
                    // Visual feedback for error
                    const tempTile = createTile(tileColor, targetIndex, 'solution');
                    tempTile.classList.add('shake');
                    
                    // Temporarily show the tile in the wrong position with shake animation
                    this.parentNode.replaceChild(tempTile, this);
                    
                    // After animation, restore empty slot
                    setTimeout(() => {
                        const newEmptySlot = document.createElement('div');
                        newEmptySlot.className = 'tile empty-slot';
                        newEmptySlot.dataset.index = targetIndex;
                        newEmptySlot.addEventListener('dragover', handleDragOver);
                        newEmptySlot.addEventListener('drop', handleDrop);
                        
                        tempTile.parentNode.replaceChild(newEmptySlot, tempTile);
                        draggedTile.style.opacity = '1';
                    }, 500);
                    
                    messageArea.textContent = "Cannot place duplicate colors in the same row!";
                    messageArea.className = 'message-area error';
                    
                    return;
                }
                
                if (isMovingWithinSolution) {
                    // If moving within solution, only allow moves within the same row
                    const sourceIndex = parseInt(draggedTile.dataset.index);
                    const sourceRow = Math.floor(sourceIndex / 5);
                    
                    if (sourceRow !== targetRow) {
                        // Cannot move between rows
                        // Visual feedback for error
                        const tempTile = createTile(tileColor, targetIndex, 'solution');
                        tempTile.classList.add('shake');
                        
                        // Temporarily show the tile in the wrong position with shake animation
                        this.parentNode.replaceChild(tempTile, this);
                        
                        // After animation, restore empty slot
                        setTimeout(() => {
                            const newEmptySlot = document.createElement('div');
                            newEmptySlot.className = 'tile empty-slot';
                            newEmptySlot.dataset.index = targetIndex;
                            newEmptySlot.addEventListener('dragover', handleDragOver);
                            newEmptySlot.addEventListener('drop', handleDrop);
                            
                            tempTile.parentNode.replaceChild(newEmptySlot, tempTile);
                            draggedTile.style.opacity = '1';
                        }, 500);
                        
                        messageArea.textContent = "Tiles can only be moved within the same row!";
                        messageArea.className = 'message-area error';
                        
                        return;
                    }
                    
                    // Remove the original tile from its position
                    const sourceSlot = document.createElement('div');
                    sourceSlot.className = 'tile empty-slot';
                    sourceSlot.dataset.index = draggedTile.dataset.index;
                    sourceSlot.addEventListener('dragover', handleDragOver);
                    sourceSlot.addEventListener('drop', handleDrop);
                    draggedTile.parentNode.replaceChild(sourceSlot, draggedTile);
                    
                    // Create a new tile for the target position
                    const newTile = createTile(tileColor, targetIndex, 'solution');
                    
                    // Replace the empty slot with the new tile
                    this.parentNode.replaceChild(newTile, this);
                    
                    // Clear any error messages
                    if (messageArea.className.includes('error')) {
                        messageArea.textContent = "";
                        messageArea.className = 'message-area';
                    }
                } else {
                    // Coming from scrambled matrix
                    
                    // Only allow placement in correct row
                    if (!colorInPalette) {
                        // Incorrect row - count as blunder and return tile to scrambled matrix
                        blunders++;
                        updateBlunderDisplay();
                        
                        // Visual feedback for error
                        const tempTile = createTile(tileColor, targetIndex, 'solution');
                        tempTile.classList.add('shake');
                        
                        // Temporarily show the tile in the wrong position with shake animation
                        this.parentNode.replaceChild(tempTile, this);
                        
                        // After animation, restore empty slot and return tile to scrambled matrix
                        setTimeout(() => {
                            const newEmptySlot = document.createElement('div');
                            newEmptySlot.className = 'tile empty-slot';
                            newEmptySlot.dataset.index = targetIndex;
                            newEmptySlot.addEventListener('dragover', handleDragOver);
                            newEmptySlot.addEventListener('drop', handleDrop);
                            
                            tempTile.parentNode.replaceChild(newEmptySlot, tempTile);
                            draggedTile.style.opacity = '1';
                        }, 500);
                        
                        messageArea.textContent = "This tile doesn't belong in this row!";
                        messageArea.className = 'message-area error';
                        
                        return;
                    }
                    
                    // The color is in the correct palette - place it in the exact position where it was dropped
                    // Create a new tile for the solution matrix
                    const newTile = createTile(tileColor, targetIndex, 'solution');
                    
                    // Replace the empty slot with the new tile
                    this.parentNode.replaceChild(newTile, this);
                    
                    // Remove the dragged tile from scrambled matrix
                    draggedTile.parentNode.removeChild(draggedTile);
                    
                    // Clear any error messages
                    if (messageArea.className.includes('error')) {
                        messageArea.textContent = "";
                        messageArea.className = 'message-area';
                    }
                }
                
                // Update active tiles
                updateActiveTiles();
                
                // Auto-check solution after each move
                checkCompletedSolution();
            }
            
            // Update tracking of active tiles
            function updateActiveTiles() {
                activeTiles = [];
                const solutionTiles = solutionMatrix.querySelectorAll('.tile:not(.empty-slot)');
                solutionTiles.forEach(tile => {
                    if (!tile.classList.contains('empty-slot')) {
                        activeTiles.push(tile);
                    }
                });
            }
            
            // Check if the current solution is correct
            function checkSolution() {
                // Toggle between showing and hiding the solution
                solutionVisible = !solutionVisible;
                
                if (solutionVisible) {
                    // Show the solution
                    showSolution();
                    checkButton.textContent = "Hide Solution";
                } else {
                    // Hide the solution and restore the current state
                    hideSolution();
                    checkButton.textContent = "Show Solution";
                }
            }
            
            // Function to show the correct solution
            function showSolution() {
                // Save current state to be able to restore it
                saveBoardState();
                
                // Clear the solution matrix except for the center column
                clearSolutionMatrix();
                
                // Place all tiles in their correct positions
                for (let row = 0; row < 5; row++) {
                    const paletteType = Object.keys(palettes)[row];
                    const correctPalette = palettes[paletteType];
                    
                    // For each row, collect all colors needed (excluding the center which is already there)
                    const colorsNeeded = [];
                    for (let col = 0; col < 5; col++) {
                        if (col !== 2) { // Skip center column
                            colorsNeeded.push(correctPalette[col]);
                        }
                    }
                    
                    // Place these colors in the available slots for this row
                    let colorsPlaced = 0;
                    for (let col = 0; col < 5; col++) {
                        if (col === 2) continue; // Skip the center column as it's already filled
                        
                        const index = row * 5 + col;
                        const colorToPlace = colorsNeeded[colorsPlaced];
                        colorsPlaced++;
                        
                        // Create a tile with the correct color
                        const newTile = createTile(colorToPlace, index, 'solution');
                        newTile.classList.add('solution-tile'); // Mark as part of the solution
                        
                        // Find the slot to replace
                        const slot = solutionMatrix.querySelector(`.tile[data-index="${index}"]`);
                        if (slot) {
                            slot.parentNode.replaceChild(newTile, slot);
                        }
                    }
                }
                
                messageArea.textContent = "ðŸ‘€ Solution shown. Click 'Hide Solution' to continue your game.";
                messageArea.className = 'message-area hint';
            }
            
            // Function to hide the solution and restore the previous state
            function hideSolution() {
                // Restore the board to its previous state
                restoreBoardState();
                
                messageArea.textContent = "Continue arranging the tiles to complete the puzzle!";
                messageArea.className = 'message-area';
            }
            
            // Function to save the current state of the board
            function saveBoardState() {
                // We'll store the state in a global variable
                window.savedState = [];
                
                // For each position in the solution matrix
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        const index = row * 5 + col;
                        const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]`);
                        
                        if (tile && !tile.classList.contains('empty-slot')) {
                            // Save the color and position
                            window.savedState.push({
                                index: index,
                                color: tile.dataset.color,
                                locked: tile.classList.contains('locked')
                            });
                        }
                    }
                }
            }
            
            // Function to clear the solution matrix except for the center column
            function clearSolutionMatrix() {
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (col === 2) continue; // Skip center column
                        
                        const index = row * 5 + col;
                        const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]`);
                        
                        if (tile && !tile.classList.contains('locked')) {
                            // Create an empty slot
                            const emptySlot = document.createElement('div');
                            emptySlot.className = 'tile empty-slot';
                            emptySlot.dataset.index = index;
                            emptySlot.addEventListener('dragover', handleDragOver);
                            emptySlot.addEventListener('drop', handleDrop);
                            
                            // Replace the tile with an empty slot
                            tile.parentNode.replaceChild(emptySlot, tile);
                        }
                    }
                }
            }
            
            // Function to restore the board to its saved state
            function restoreBoardState() {
                // First clear the board (except center column)
                clearSolutionMatrix();
                
                // Then restore each saved tile
                if (window.savedState) {
                    window.savedState.forEach(saved => {
                        // Skip locked tiles (they're already there)
                        if (saved.locked) return;
                        
                        const index = saved.index;
                        const slot = solutionMatrix.querySelector(`.tile[data-index="${index}"]`);
                        
                        if (slot) {
                            const newTile = createTile(saved.color, index, 'solution');
                            slot.parentNode.replaceChild(newTile, slot);
                        }
                    });
                }
            }
            
            // Function to verify if the solution is correct
            function verifySolution() {
                let allCorrect = true;
                
                // Check each row
                for (let row = 0; row < 5; row++) {
                    const paletteType = Object.keys(palettes)[row];
                    const correctPalette = palettes[paletteType];
                    
                    // Get the tiles in this row
                    const rowTiles = [];
                    for (let col = 0; col < 5; col++) {
                        const index = row * 5 + col;
                        const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]`);
                        if (tile && !tile.classList.contains('empty-slot')) {
                            rowTiles.push(tile);
                        }
                    }
                    
                    // Skip incomplete rows
                    if (rowTiles.length < 5) {
                        allCorrect = false;
                        continue;
                    }
                    
                    // Check if colors match the correct palette (order doesn't matter)
                    const rowColors = rowTiles.map(tile => tile.dataset.color);
                    
                    // Create a frequency map of colors
                    const correctColorCounts = {};
                    const rowColorCounts = {};
                    
                    for (const color of correctPalette) {
                        correctColorCounts[color] = (correctColorCounts[color] || 0) + 1;
                    }
                    
                    for (const color of rowColors) {
                        rowColorCounts[color] = (rowColorCounts[color] || 0) + 1;
                    }
                    
                    // Check if both maps have the same keys and values
                    const colorsMatch = Object.keys(correctColorCounts).length === Object.keys(rowColorCounts).length &&
                        Object.keys(correctColorCounts).every(key => 
                            correctColorCounts[key] === rowColorCounts[key]
                        );
                    
                    if (!colorsMatch) {
                        allCorrect = false;
                    }
                }
                
                if (allCorrect) {
                    showSuccess();
                } else {
                    showError();
                }
                
                return allCorrect;
            }
            
            // Helper to compare arrays
            function arraysEqual(a, b) {
                if (a.length !== b.length) return false;
                for (let i = 0; i < a.length; i++) {
                    if (a[i] !== b[i]) return false;
                }
                return true;
            }
            
            // Update the blunder display
            function updateBlunderDisplay() {
                const blunderDisplay = document.getElementById('blunder-value');
                blunderDisplay.textContent = blunders;
            }
            
            // Update the timer display
            function updateTimer() {
                if (!startTime) return;
                
                const currentTime = new Date();
                const elapsedTime = Math.floor((currentTime - startTime) / 1000);
                
                const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
                const seconds = (elapsedTime % 60).toString().padStart(2, '0');
                
                const timerDisplay = document.getElementById('timer-value');
                timerDisplay.textContent = `${minutes}:${seconds}`;
            }
            
            // Show success message
            function showSuccess() {
                // Stop the timer
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                
                // Calculate final time
                const currentTime = new Date();
                const elapsedSeconds = Math.floor((currentTime - startTime) / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                
                messageArea.textContent = `ðŸŽ‰ Congratulations! You solved it in ${minutes}m ${seconds}s with ${blunders} blunders!`;
                messageArea.className = 'message-area success';
                
                // Add celebration animation
                activeTiles.forEach(tile => {
                    tile.classList.add('correct');
                    setTimeout(() => {
                        tile.classList.remove('correct');
                    }, 1000);
                });
            }
            
            // Show error message
            function showError() {
                messageArea.textContent = 'Not quite right. Keep working on the palette arrangements!';
                messageArea.className = 'message-area error';
            }
            
            // Show hint
            function showHint() {
                // Find the three rows with the fewest tiles placed
                const rowCompletion = [0, 0, 0, 0, 0]; // Track how many tiles are placed in each row
                
                // Count placed tiles in each row (excluding the locked center tile)
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        if (col === 2) continue; // Skip center column (it's always filled)
                        
                        const index = row * 5 + col;
                        const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]:not(.empty-slot)`);
                        
                        if (tile && !tile.classList.contains('empty-slot')) {
                            rowCompletion[row]++;
                        }
                    }
                }
                
                // Find the three rows with the least completion
                const rowIndices = [0, 1, 2, 3, 4];
                rowIndices.sort((a, b) => rowCompletion[a] - rowCompletion[b]);
                const rowsNeedingHelp = rowIndices.slice(0, 3);
                
                // Text hints based on which rows need help
                const hintMessages = {
                    0: "Monochromatic palettes show different brightness levels of the same color.",
                    1: "Analogous palettes contain colors that are next to each other on the color wheel.",
                    2: "Complementary palettes use colors from opposite sides of the color wheel.",
                    3: "Split complementary palettes use a color and two colors adjacent to its complement.",
                    4: "Triadic palettes use three colors evenly spaced around the color wheel."
                };
                
                // Choose one of the rows needing help and give specific hint
                const focusRow = rowsNeedingHelp[0];
                const paletteType = Object.keys(palettes)[focusRow];
                const palette = palettes[paletteType];
                
                // Find an empty slot to suggest a tile for
                let suggestedCol = -1;
                let suggestedColor = null;
                
                // First check if columns 0 and 1 are empty
                for (let col of [0, 1]) {
                    const index = focusRow * 5 + col;
                    const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]:not(.empty-slot)`);
                    
                    if (!tile || tile.classList.contains('empty-slot')) {
                        suggestedCol = col;
                        suggestedColor = palette[col];
                        break;
                    }
                }
                
                // If columns 0 and 1 are filled, check columns 3 and 4
                if (suggestedCol === -1) {
                    for (let col of [3, 4]) {
                        const index = focusRow * 5 + col;
                        const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]:not(.empty-slot)`);
                        
                        if (!tile || tile.classList.contains('empty-slot')) {
                            suggestedCol = col;
                            suggestedColor = palette[col];
                            break;
                        }
                    }
                }
                
                // Highlight the color in scrambled matrix
                let highlightedTile = null;
                if (suggestedColor) {
                    const scrambledTiles = scrambledMatrix.querySelectorAll('.tile');
                    
                    for (const tile of scrambledTiles) {
                        if (tile.dataset.color === suggestedColor) {
                            // Add highlighting to this tile
                            tile.style.boxShadow = '0 0 15px gold, 0 0 8px gold';
                            tile.style.transform = 'scale(1.1)';
                            highlightedTile = tile;
                            break;
                        }
                    }
                }
                
                // Remove highlighting after 3 seconds
                if (highlightedTile) {
                    setTimeout(() => {
                        if (highlightedTile.parentNode) { // Check if the tile is still in the DOM
                            highlightedTile.style.boxShadow = '';
                            highlightedTile.style.transform = '';
                        }
                    }, 3000);
                }
                
                // Generate message for the rows that need help
                let hintText = 'ðŸ’¡ Hint: Focus on these rows: ';
                rowsNeedingHelp.forEach((rowIndex, i) => {
                    hintText += `Row ${rowIndex + 1} (${hintMessages[rowIndex].split(' ')[0]})`;
                    if (i < rowsNeedingHelp.length - 1) {
                        hintText += ', ';
                    }
                });
                
                messageArea.textContent = hintText;
                messageArea.className = 'message-area hint';
            }
            
            // Add a method to verify the solution and show a success message when correct
            function checkCompletedSolution() {
                // Only verify if solution is not currently being shown
                if (!solutionVisible) {
                    verifySolution();
                }
            }
            
            // Function to toggle palette type visibility
            function togglePaletteTypes() {
                paletteTypesVisible = !paletteTypesVisible;
                
                const rowLabels = document.querySelector('.row-labels');
                const paletteButton = document.getElementById('palette-button');
                
                if (paletteTypesVisible) {
                    // Show palette types
                    rowLabels.classList.add('visible');
                    paletteButton.textContent = "Hide Palette Types";
                    
                    // Show a message explaining palette types
                    messageArea.textContent = "Palette types shown. Each row corresponds to a different color relationship pattern.";
                    messageArea.className = 'message-area hint';
                } else {
                    // Hide palette types
                    rowLabels.classList.remove('visible');
                    paletteButton.textContent = "Show Palette Types";
                    
                    // Clear message area if it's showing the palette message
                    if (messageArea.textContent.includes("Palette types shown")) {
                        messageArea.textContent = "";
                        messageArea.className = 'message-area';
                    }
                }
            }
            
            // Event listeners
            checkButton.addEventListener('click', checkSolution);
            hintButton.addEventListener('click', showHint);
            const paletteButton = document.getElementById('palette-button');
            paletteButton.addEventListener('click', togglePaletteTypes);
            resetButton.addEventListener('click', initGame);
            
            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>