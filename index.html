<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shades: Color Theory Puzzle Game</title>
    <style>
        /* Modern, clean design with professional color palette */
        :root {
            --primary: #3a506b;
            --secondary: #5bc0be;
            --light: #f0f5f9;
            --dark: #1c2541;
            --accent: #6fffe9;
            --success: #4caf50;
            --error: #f44336;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--light);
            color: var(--dark);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--secondary);
            margin-bottom: 20px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            width: 95%;
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (min-width: 900px) {
            .game-container {
                flex-direction: row;
                align-items: flex-start;
            }
        }

        .matrix-container {
            flex: 1;
            background-color: white;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .matrix-title {
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary);
            font-size: 1.5rem;
        }

        .matrix {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 12px;
            aspect-ratio: 1/1;
            width: 100%;
            min-height: 400px;
        }

        .tile {
            position: relative;
            border-radius: 8px;
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            aspect-ratio: 1/1;
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .tile.locked {
            cursor: not-allowed;
            overflow: hidden;
        }

        .tile.locked::after {
            content: "ðŸ”’";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:hover {
            background-color: #2a3f56;
        }

        button:active {
            transform: scale(0.98);
        }

        #hint-button {
            background-color: var(--secondary);
        }

        #hint-button:hover {
            background-color: #4ca8a6;
        }

        #check-button {
            background-color: var(--accent);
            color: var(--dark);
        }

        #check-button:hover {
            background-color: #63e5d1;
        }

        #reset-button {
            background-color: var(--dark);
        }

        #reset-button:hover {
            background-color: #141e32;
        }

        .message-area {
            min-height: 60px;
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .success {
            background-color: rgba(76, 175, 80, 0.2);
            color: var(--success);
        }

        .error {
            background-color: rgba(244, 67, 54, 0.2);
            color: var(--error);
        }

        .hint {
            background-color: rgba(91, 192, 190, 0.2);
            color: var(--secondary);
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 800px;
        }
        
        .stat {
            text-align: center;
            font-weight: bold;
        }
        
        .stat-value {
            font-size: 1.5rem;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: var(--secondary);
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-10px); }
            80% { transform: translateX(10px); }
        }
        
        .shake {
            animation: shake 0.5s;
            border: 2px solid var(--error);
        }
        
        .game-info {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 800px;
        }

        .game-info h2 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .game-info p {
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .palette-info {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .palette-type {
            flex: 1 1 200px;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
        }

        .palette-type h3 {
            font-size: 1rem;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .color-sample {
            display: flex;
            height: 20px;
            margin-top: 5px;
        }
        
        .color-sample div {
            flex: 1;
            height: 100%;
        }

        @media (max-width: 768px) {
            .matrix {
                gap: 8px;
                min-height: 300px;
            }
            
            .controls {
                flex-direction: column;
                width: 100%;
            }
            
            button {
                width: 100%;
            }
        }

        /* Animation for when tiles are placed correctly */
        @keyframes correctPlacement {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .correct {
            animation: correctPlacement 0.5s;
            border: 2px solid var(--success);
        }
    </style>
</head>
<body>
    <header>
        <h1>Shades</h1>
        <div class="subtitle">Color Theory Puzzle Game</div>
    </header>

    <div class="game-container">
        <div class="matrix-container">
            <h2 class="matrix-title">Scrambled Matrix</h2>
            <div id="scrambled-matrix" class="matrix">
                <!-- Tiles will be generated by JavaScript -->
            </div>
        </div>
        
        <div class="matrix-container">
            <h2 class="matrix-title">Solution Matrix</h2>
            <div id="solution-matrix" class="matrix">
                <!-- Tiles will be generated by JavaScript -->
            </div>
        </div>
    </div>
    
    <div id="message" class="message-area"></div>
    
    <div class="game-stats">
        <div class="stat">
            <div id="timer-value" class="stat-value">00:00</div>
            <div class="stat-label">Time</div>
        </div>
        <div class="stat">
            <div id="blunder-value" class="stat-value">0</div>
            <div class="stat-label">Blunders</div>
        </div>
    </div>
    
    <div class="controls">
        <button id="check-button">Check Solution</button>
        <button id="hint-button">Show Hint</button>
        <button id="reset-button">Reset Game</button>
    </div>

    <div class="game-info">
        <h2>How to Play:</h2>
        <p>Drag tiles from the Scrambled Matrix on the left and drop them into the Solution Matrix on the right. The center column shows key colors for each palette type. Arrange tiles to match the correct color relationships and click "Check Solution" to verify your arrangement.</p>
        
        <div class="palette-info">
            <div class="palette-type">
                <h3>Row 1: Monochromatic</h3>
                <p>Variations in lightness of a single hue</p>
                <div class="color-sample">
                    <div style="background-color: #bde0fe;"></div>
                    <div style="background-color: #a2d2ff;"></div>
                    <div style="background-color: #8ac8ff;"></div>
                    <div style="background-color: #72beff;"></div>
                    <div style="background-color: #5ab4ff;"></div>
                </div>
            </div>
            <div class="palette-type">
                <h3>Row 2: Analogous</h3>
                <p>Adjacent colors on the color wheel</p>
                <div class="color-sample">
                    <div style="background-color: #ffadad;"></div>
                    <div style="background-color: #ffd6a5;"></div>
                    <div style="background-color: #fdffb6;"></div>
                    <div style="background-color: #caffbf;"></div>
                    <div style="background-color: #9bf6ff;"></div>
                </div>
            </div>
            <div class="palette-type">
                <h3>Row 3: Complementary</h3>
                <p>Opposite colors on the color wheel</p>
                <div class="color-sample">
                    <div style="background-color: #ff5c8a;"></div>
                    <div style="background-color: #ff8fab;"></div>
                    <div style="background-color: #ffffff;"></div>
                    <div style="background-color: #a0c4ff;"></div>
                    <div style="background-color: #4361ee;"></div>
                </div>
            </div>
            <div class="palette-type">
                <h3>Row 4: Split Complementary</h3>
                <p>Base + two flanking colors</p>
                <div class="color-sample">
                    <div style="background-color: #ff7b00;"></div>
                    <div style="background-color: #ff9e00;"></div>
                    <div style="background-color: #40916c;"></div>
                    <div style="background-color: #52b788;"></div>
                    <div style="background-color: #b5179e;"></div>
                </div>
            </div>
            <div class="palette-type">
                <h3>Row 5: Triadic</h3>
                <p>Three equidistant colors</p>
                <div class="color-sample">
                    <div style="background-color: #f15bb5;"></div>
                    <div style="background-color: #f8c537;"></div>
                    <div style="background-color: #00bbf9;"></div>
                    <div style="background-color: #f15bb5;"></div>
                    <div style="background-color: #00bbf9;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Color palettes definition (these could be generated programmatically in a more advanced version)
            const palettes = {
                monochromatic: ['#e6f2ff', '#bfd9ff', '#99c2ff', '#6699ff', '#3366ff'],
                analogous: ['#ff9999', '#ffcc99', '#ffff99', '#ccff99', '#99ffcc'],
                complementary: ['#ff5555', '#ff9999', '#ffffff', '#9999ff', '#5555ff'],
                splitComplementary: ['#ff6600', '#ff9933', '#33cc99', '#66cc99', '#cc33cc'],
                triadic: ['#ff5555', '#55ff55', '#5555ff', '#ff5555', '#5555ff']
            };
            
            // Game elements
            const scrambledMatrix = document.getElementById('scrambled-matrix');
            const solutionMatrix = document.getElementById('solution-matrix');
            const messageArea = document.getElementById('message');
            const checkButton = document.getElementById('check-button');
            const hintButton = document.getElementById('hint-button');
            const resetButton = document.getElementById('reset-button');
            
            // Game state
            let draggedTile = null;
            let activeTiles = [];
            let blunders = 0;
            let startTime = null;
            let timerInterval = null;
            
            // Initialize game
            function initGame() {
                // Clear matrices
                scrambledMatrix.innerHTML = '';
                solutionMatrix.innerHTML = '';
                messageArea.textContent = '';
                messageArea.className = 'message-area';
                
                // Reset game stats
                blunders = 0;
                updateBlunderDisplay();
                
                // Reset and start timer
                startTime = new Date();
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(updateTimer, 1000);
                updateTimer();
                
                // Create all color tiles
                const allColors = [];
                Object.values(palettes).forEach(palette => {
                    allColors.push(...palette);
                });
                
                // Create scrambled tiles
                const scrambledColors = [...allColors].sort(() => Math.random() - 0.5);
                scrambledColors.forEach((color, index) => {
                    const tile = createTile(color, index, 'scrambled');
                    tile.dataset.originalIndex = index; // Store original position
                    scrambledMatrix.appendChild(tile);
                });
                
                // Create solution matrix with locked center column
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 5; col++) {
                        // Calculate the index in a 5x5 grid
                        const index = row * 5 + col;
                        
                        // For center column (col = 2), place locked tiles with the correct colors
                        if (col === 2) {
                            const paletteType = Object.keys(palettes)[row];
                            const palette = palettes[paletteType];
                            const centerTile = createTile(palette[2], index, 'locked');
                            centerTile.classList.add('locked');
                            solutionMatrix.appendChild(centerTile);
                        } else {
                            // Create empty slots for other positions
                            const emptySlot = document.createElement('div');
                            emptySlot.className = 'tile empty-slot';
                            emptySlot.dataset.index = index;
                            emptySlot.addEventListener('dragover', handleDragOver);
                            emptySlot.addEventListener('drop', handleDrop);
                            solutionMatrix.appendChild(emptySlot);
                        }
                    }
                }
                
                // Update active tiles
                updateActiveTiles();
            }
            
            // Create a color tile
            function createTile(color, index, type) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                
                // Create subtle gradient effect with the base color
                const lighterColor = lightenColor(color, 15);
                const darkerColor = darkenColor(color, 15);
                tile.style.background = `linear-gradient(135deg, ${lighterColor}, ${color} 50%, ${darkerColor})`;
                
                tile.dataset.color = color;
                tile.dataset.index = index;
                
                // Make scrambled tiles draggable
                if (type === 'scrambled') {
                    tile.draggable = true;
                    tile.addEventListener('dragstart', handleDragStart);
                    tile.addEventListener('dragend', handleDragEnd);
                }
                
                return tile;
            }
            
            // Helper function to lighten a color
            function lightenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, (num >> 16) + amt);
                const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
                const B = Math.min(255, (num & 0x0000FF) + amt);
                return '#' + (0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1);
            }
            
            // Helper function to darken a color
            function darkenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.max(0, (num >> 16) - amt);
                const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
                const B = Math.max(0, (num & 0x0000FF) - amt);
                return '#' + (0x1000000 + (R << 16) + (G << 8) + B).toString(16).slice(1);
            }
            
            // Drag and Drop Handlers
            function handleDragStart(e) {
                draggedTile = this;
                this.style.opacity = '0.4';
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.color);
            }
            
            function handleDragEnd(e) {
                this.style.opacity = '1';
                draggedTile = null;
            }
            
            function handleDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary to allow drop
                }
                e.dataTransfer.dropEffect = 'move';
                return false;
            }
            
            function handleDrop(e) {
                e.preventDefault();
                
                if (!draggedTile) return;
                
                // Get the row of the drop target and color info
                const targetIndex = parseInt(this.dataset.index);
                const targetRow = Math.floor(targetIndex / 5);
                const paletteType = Object.keys(palettes)[targetRow];
                const correctPalette = palettes[paletteType];
                const tileColor = draggedTile.dataset.color;
                
                // Check if the color belongs to the correct palette (correct row)
                const colorInPalette = correctPalette.includes(tileColor);
                
                // Get existing tiles in this row to check correct order
                const rowTiles = [];
                for (let col = 0; col < 5; col++) {
                    const index = targetRow * 5 + col;
                    const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]:not(.empty-slot)`);
                    if (tile) {
                        rowTiles.push({
                            color: tile.dataset.color,
                            index: col
                        });
                    }
                }
                
                // Calculate the correct position for this color in this row
                const correctPositionInRow = correctPalette.indexOf(tileColor);
                const targetCol = targetIndex % 5;
                
                // Check if position is correct within the row (considering existing tiles)
                let positionCorrect = true;
                
                if (colorInPalette && correctPositionInRow !== -1) {
                    // Check if we're trying to place the tile in the wrong position
                    if (targetCol !== correctPositionInRow) {
                        positionCorrect = false;
                    }
                    
                    // Check if this placement would create an inconsistent order with existing tiles
                    for (const existingTile of rowTiles) {
                        const existingColorIndex = correctPalette.indexOf(existingTile.color);
                        if (existingColorIndex !== -1) { // Only consider tiles from the correct palette
                            if ((existingColorIndex < correctPositionInRow && existingTile.index > targetCol) ||
                                (existingColorIndex > correctPositionInRow && existingTile.index < targetCol)) {
                                positionCorrect = false;
                                break;
                            }
                        }
                    }
                }
                
                if (!colorInPalette || !positionCorrect) {
                    // Incorrect placement - count as blunder and return tile to scrambled matrix
                    blunders++;
                    updateBlunderDisplay();
                    
                    // Visual feedback for error
                    const tempTile = createTile(tileColor, targetIndex, 'solution');
                    tempTile.classList.add('shake');
                    
                    // Temporarily show the tile in the wrong position with shake animation
                    this.parentNode.replaceChild(tempTile, this);
                    
                    // After animation, restore empty slot and return tile to scrambled matrix
                    setTimeout(() => {
                        // Create a new empty slot
                        const newEmptySlot = document.createElement('div');
                        newEmptySlot.className = 'tile empty-slot';
                        newEmptySlot.dataset.index = targetIndex;
                        newEmptySlot.addEventListener('dragover', handleDragOver);
                        newEmptySlot.addEventListener('drop', handleDrop);
                        
                        // Replace the temporary tile with the empty slot
                        tempTile.parentNode.replaceChild(newEmptySlot, tempTile);
                        
                        // Make dragged tile visible again in the scrambled matrix
                        draggedTile.style.opacity = '1';
                    }, 500);
                    
                } else {
                    // Correct placement - proceed as normal
                    // Create a new tile with the same color at the drop position
                    const newTile = createTile(tileColor, targetIndex, 'solution');
                    
                    // Replace the target slot with the new tile
                    this.parentNode.replaceChild(newTile, this);
                    
                    // Remove the dragged tile from scrambled matrix
                    draggedTile.parentNode.removeChild(draggedTile);
                }
                
                // Update active tiles
                updateActiveTiles();
            }
            
            // Update tracking of active tiles
            function updateActiveTiles() {
                activeTiles = [];
                const solutionTiles = solutionMatrix.querySelectorAll('.tile:not(.empty-slot)');
                solutionTiles.forEach(tile => {
                    if (!tile.classList.contains('empty-slot')) {
                        activeTiles.push(tile);
                    }
                });
            }
            
            // Check if the current solution is correct
            function checkSolution() {
                let allCorrect = true;
                
                // Check each row
                for (let row = 0; row < 5; row++) {
                    const paletteType = Object.keys(palettes)[row];
                    const correctPalette = palettes[paletteType];
                    
                    // Get the tiles in this row
                    const rowTiles = [];
                    for (let col = 0; col < 5; col++) {
                        const index = row * 5 + col;
                        const tile = solutionMatrix.querySelector(`.tile[data-index="${index}"]`);
                        if (tile && !tile.classList.contains('empty-slot')) {
                            rowTiles.push(tile);
                        }
                    }
                    
                    // Skip incomplete rows
                    if (rowTiles.length < 5) {
                        allCorrect = false;
                        continue;
                    }
                    
                    // Check if colors match the correct palette
                    const rowColors = rowTiles.map(tile => tile.dataset.color);
                    const rowCorrect = arraysEqual(rowColors, correctPalette);
                    
                    if (!rowCorrect) {
                        allCorrect = false;
                    }
                }
                
                if (allCorrect) {
                    showSuccess();
                } else {
                    showError();
                }
            }
            
            // Helper to compare arrays
            function arraysEqual(a, b) {
                if (a.length !== b.length) return false;
                for (let i = 0; i < a.length; i++) {
                    if (a[i] !== b[i]) return false;
                }
                return true;
            }
            
            // Update the blunder display
            function updateBlunderDisplay() {
                const blunderDisplay = document.getElementById('blunder-value');
                blunderDisplay.textContent = blunders;
            }
            
            // Update the timer display
            function updateTimer() {
                if (!startTime) return;
                
                const currentTime = new Date();
                const elapsedTime = Math.floor((currentTime - startTime) / 1000);
                
                const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
                const seconds = (elapsedTime % 60).toString().padStart(2, '0');
                
                const timerDisplay = document.getElementById('timer-value');
                timerDisplay.textContent = `${minutes}:${seconds}`;
            }
            
            // Show success message
            function showSuccess() {
                // Stop the timer
                if (timerInterval) {
                    clearInterval(timerInterval);
                }
                
                // Calculate final time
                const currentTime = new Date();
                const elapsedSeconds = Math.floor((currentTime - startTime) / 1000);
                const minutes = Math.floor(elapsedSeconds / 60);
                const seconds = elapsedSeconds % 60;
                
                messageArea.textContent = `ðŸŽ‰ Congratulations! You solved it in ${minutes}m ${seconds}s with ${blunders} blunders!`;
                messageArea.className = 'message-area success';
                
                // Add celebration animation
                activeTiles.forEach(tile => {
                    tile.classList.add('correct');
                    setTimeout(() => {
                        tile.classList.remove('correct');
                    }, 1000);
                });
            }
            
            // Show error message
            function showError() {
                messageArea.textContent = 'Not quite right. Keep working on the palette arrangements!';
                messageArea.className = 'message-area error';
            }
            
            // Show hint
            function showHint() {
                const hints = [
                    "Monochromatic palettes (Row 1) show different brightness levels of the same color.",
                    "Analogous palettes (Row 2) contain colors that are next to each other on the color wheel.",
                    "Complementary palettes (Row 3) use colors from opposite sides of the color wheel.",
                    "Split complementary palettes (Row 4) use a color and two colors adjacent to its complement.",
                    "Triadic palettes (Row 5) use three colors evenly spaced around the color wheel."
                ];
                
                const randomHint = hints[Math.floor(Math.random() * hints.length)];
                messageArea.textContent = 'ðŸ’¡ Hint: ' + randomHint;
                messageArea.className = 'message-area hint';
            }
            
            // Event listeners
            checkButton.addEventListener('click', checkSolution);
            hintButton.addEventListener('click', showHint);
            resetButton.addEventListener('click', initGame);
            
            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>